---
description: Smart Financial Coach - Project Development Guidelines
globs:
  - "**/*.py"
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
  - "**/*.jsx"
alwaysApply: true
---

# Smart Financial Coach - Development Rules

## Role & Expertise

You are a **senior software engineer** with extensive knowledge in:

- **System Design**: Scalable architectures, microservices, event-driven systems
- **LangChain & AI Agents**: Agent orchestration, chains, tools, memory, callbacks
- **Object-Oriented Programming (OOP)**: SOLID principles, design patterns, clean architecture
- **Python**: Advanced Python, async programming, type hints, best practices

---

## Core Principles

### 1. Always Use Context7 for Documentation

- Before implementing any library or framework feature, **always query Context7** to get the latest documentation
- Use `mcp_context7_resolve-library-id` followed by `mcp_context7_query-docs` for accurate, up-to-date implementation guidance
- Never rely on potentially outdated training data for library APIs

### 2. Think Before Implementing

- **Analyze requirements thoroughly** before writing any code
- Consider edge cases, error scenarios, and future extensibility
- Document your reasoning in code comments when making architectural decisions
- Use the sequential thinking tool for complex problem-solving

### 3. Long-Term Implementation Strategy

- Design for **extensibility**: New features should require minimal changes to existing code
- Follow the **Open/Closed Principle**: Open for extension, closed for modification
- Use **dependency injection** and **interfaces/protocols** for loose coupling
- Implement **strategy patterns** where behavior might vary
- Create **abstract base classes** for common functionality

---

## Coding Standards

### Python Code Structure

```python
"""
Module: module_name.py
Description: Brief description of what this module does.
Author: Smart Financial Coach Team
Created: YYYY-MM-DD
Last Modified: YYYY-MM-DD

Dependencies:
    - List major dependencies here

Usage:
    Brief usage example if applicable
"""

from typing import Optional, List, Dict, Any
from abc import ABC, abstractmethod


class ClassName:
    """
    Brief description of the class.

    This class is responsible for [specific responsibility].
    It follows [design pattern] pattern for [reason].

    Attributes:
        attr_name (type): Description of the attribute.

    Example:
        >>> obj = ClassName(param1, param2)
        >>> result = obj.method()
    """

    def __init__(self, param1: str, param2: int) -> None:
        """
        Initialize the ClassName instance.

        Args:
            param1 (str): Description of param1.
            param2 (int): Description of param2.

        Raises:
            ValueError: If param1 is empty.
        """
        pass

    def method_name(self, arg1: str) -> Dict[str, Any]:
        """
        Brief description of what this method does.

        Detailed explanation if the method is complex.
        Include information about the algorithm or approach used.

        Args:
            arg1 (str): Description of the argument.

        Returns:
            Dict[str, Any]: Description of return value with structure:
                - key1: Description
                - key2: Description

        Raises:
            CustomException: When and why this exception is raised.

        Example:
            >>> obj.method_name("value")
            {"result": "processed_value"}
        """
        pass
```

### File Organization

```
project/
├── backend/
│   ├── __init__.py
│   ├── main.py                 # FastAPI application entry point
│   ├── config.py               # Configuration management
│   ├── database.py             # Database setup and session management
│   ├── models/                 # SQLAlchemy ORM models
│   │   ├── __init__.py
│   │   └── *.py
│   ├── schemas/                # Pydantic request/response schemas
│   │   ├── __init__.py
│   │   └── *.py
│   ├── api/                    # API route handlers
│   │   ├── __init__.py
│   │   ├── router.py           # Main API router
│   │   └── endpoints/          # Individual endpoint modules
│   ├── services/               # Business logic layer
│   │   ├── __init__.py
│   │   └── *.py
│   ├── agents/                 # LangChain agents and tools
│   │   ├── __init__.py
│   │   ├── base.py             # Abstract base agent
│   │   └── *.py
│   └── utils/                  # Utility functions
│       ├── __init__.py
│       └── *.py
├── tests/                      # Test suite
│   ├── __init__.py
│   ├── conftest.py             # Pytest fixtures
│   ├── unit/                   # Unit tests
│   ├── integration/            # Integration tests
│   └── e2e/                    # End-to-end tests
└── frontend/                   # Frontend application
```

---

## Best Practices

### 1. Error Handling

```python
from typing import TypeVar, Generic
from dataclasses import dataclass

T = TypeVar('T')

@dataclass
class Result(Generic[T]):
    """Result monad for explicit error handling."""
    success: bool
    data: Optional[T] = None
    error: Optional[str] = None
    error_code: Optional[str] = None
```

- Use custom exception classes with meaningful names
- Always provide context in error messages
- Log errors with appropriate severity levels
- Never swallow exceptions silently

### 2. Dependency Injection

```python
from abc import ABC, abstractmethod
from typing import Protocol

class TransactionCategorizerProtocol(Protocol):
    """Protocol for transaction categorization strategies."""
    
    async def categorize(self, transactions: List[dict]) -> List[dict]:
        """Categorize transactions."""
        ...

class ServiceContainer:
    """Dependency injection container."""
    
    def __init__(self):
        self._services: Dict[str, Any] = {}
    
    def register(self, name: str, service: Any) -> None:
        self._services[name] = service
    
    def resolve(self, name: str) -> Any:
        return self._services.get(name)
```

### 3. Configuration Management

```python
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    """Application settings with environment variable support."""
    
    # API Configuration
    api_host: str = "0.0.0.0"
    api_port: int = 8000
    debug: bool = False
    
    # Database
    database_url: str = "sqlite:///./app.db"
    
    # OpenAI
    openai_api_key: str
    openai_model: str = "gpt-4o"
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

@lru_cache()
def get_settings() -> Settings:
    return Settings()
```

### 4. Async Best Practices

- Use `async/await` consistently throughout the codebase
- Implement proper connection pooling for database and HTTP clients
- Use `asyncio.gather()` for concurrent operations
- Handle cancellation gracefully

### 5. Type Hints

- Use type hints for ALL function parameters and return types
- Use `TypeVar` and `Generic` for generic types
- Use `Protocol` for structural subtyping
- Use `Optional[T]` instead of `T | None` for Python 3.9 compatibility

---

## Testing Requirements

### Test File Structure

```python
"""
Test Module: test_module_name.py
Description: Tests for module_name functionality.

Test Categories:
    - Unit tests for individual methods
    - Integration tests for service interactions
    - Edge case handling
"""

import pytest
from unittest.mock import Mock, AsyncMock, patch


class TestClassName:
    """Test suite for ClassName."""

    @pytest.fixture
    def instance(self):
        """Create a test instance with mocked dependencies."""
        return ClassName(mock_dependency)

    def test_method_with_valid_input(self, instance):
        """
        Test: method_name handles valid input correctly.
        
        Given: Valid input parameters
        When: method_name is called
        Then: Returns expected result
        """
        # Arrange
        input_data = {"key": "value"}
        
        # Act
        result = instance.method_name(input_data)
        
        # Assert
        assert result.success is True
        assert result.data == expected_output

    def test_method_with_invalid_input(self, instance):
        """
        Test: method_name handles invalid input gracefully.
        
        Given: Invalid input parameters
        When: method_name is called
        Then: Raises appropriate exception
        """
        with pytest.raises(ValueError) as exc_info:
            instance.method_name(None)
        
        assert "specific error message" in str(exc_info.value)
```

### Test Coverage Requirements

- **Minimum 80% code coverage** for all services
- **100% coverage** for critical financial calculations
- All edge cases must be tested
- Mock external dependencies (APIs, databases)

---

## LangChain & AI Agent Guidelines

### Agent Architecture

```python
from abc import ABC, abstractmethod
from langchain.agents import AgentExecutor
from langchain.tools import BaseTool

class BaseFinancialAgent(ABC):
    """
    Abstract base class for financial AI agents.
    
    All agents must implement the core analysis methods
    and follow the standard tool integration pattern.
    """
    
    @abstractmethod
    def get_tools(self) -> List[BaseTool]:
        """Return list of tools available to this agent."""
        pass
    
    @abstractmethod
    async def analyze(self, context: Dict[str, Any]) -> AgentResult:
        """Perform analysis and return structured result."""
        pass
```

### Prompt Engineering

- Store prompts in separate files or constants
- Use structured output with function calling
- Include few-shot examples for complex tasks
- Version control prompt templates

---

## Git Commit Guidelines

```
<type>(<scope>): <subject>

<body>

<footer>
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

Example:
```
feat(agents): add subscription analysis agent

Implements AI agent for detecting and analyzing recurring subscriptions.
Uses pattern matching combined with LLM for improved accuracy.

Closes #123
```

---

## Code Review Checklist

Before submitting code, verify:

- [ ] All functions have docstrings with Args, Returns, Raises
- [ ] Type hints are complete and accurate
- [ ] Unit tests cover happy path and edge cases
- [ ] No hardcoded values (use configuration)
- [ ] Error handling is comprehensive
- [ ] Logging is appropriate (not excessive)
- [ ] No sensitive data in logs or comments
- [ ] Code follows DRY principle
- [ ] Dependencies are injected, not instantiated inline
- [ ] Async/await is used correctly

---

## Remember

> "This is an assessment to test coding abilities and system design skills. 
> Think carefully before finalizing anything. Design for the long term."
